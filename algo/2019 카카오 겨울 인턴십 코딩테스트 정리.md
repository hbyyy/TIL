## 2019 카카오 겨울 인턴십 코딩테스트 정리

### 1. 크레인 인형뽑기 게임

[문제 풀기](https://programmers.co.kr/learn/courses/30/lessons/64061)

- 문제 설명

  - 게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.
    죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.

    ![crane_game_101.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png)

    게임 화면은 **1 x 1** 크기의 칸들로 이루어진 **N x N** 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 **격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다.** 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.

    ![crane_game_102.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png)

    만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 **두 개**가 없어집니다.

    ![crane_game_103.gif](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif)

    크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)

    게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.

    ##### **[제한사항]**

    - board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다.
    - board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.
      - 0은 빈 칸을 나타냅니다.
      - 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.
    - moves 배열의 크기는 1 이상 1,000 이하입니다.
    - moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.

- 입출력 예시

  - | board                                                        | moves             | result |
    | ------------------------------------------------------------ | ----------------- | ------ |
    | [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] | [1,5,3,5,1,2,1,4] | 4      |



- 내 풀이

   2차원 리스트와 스택의 성질을 이용하면 간단하게 풀 수 있는 문제였다. 처음에는 문제 해석을 잘못해서 입력 리스트인 board 리스트의 원소 리스트 하나하나가 인형뽑기의 하나의 열 인줄 알았는데, 열이 아니라 행이었다! 즉 인형뽑기에는,

  | 인형뽑기 board                                               | 맞는 상태                                                    |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | \| 0 0 0 0 0 \|<br />\| 0 0 1 0 3 \|<br />\| 0 2 5 0 1 \|<br />\| 4 2 4 4 2 \|<br />\| 3 5 1 3 1 \|<br />\| ------------ \|<br />[ 1 2 3 4 5 ] | \| 0 0 0 4 3\|<br />\| 0 0 2 2 5\|<br />\| 0 1 5 4 1\|<br />\| 0 0 0 4 3\|<br />\| 0 3 1 2 1\|<br />\|------------ \|<br />[ 1 2 3 4 5 ] |

   이런 식으로 인형이 들어있는 것이다. 처음 생각한 board에는 인형뽑기 라인 중간에도 0이 있어 뭔가 이상하다 생각했는데, 문제를 잘못 해석한 것이였다!

   나머지 풀이는 쉬운 편이었다. 간단히 요약하면, 뽑은 인형을 보관하는 basket 리스트를 하나 만들고, 그 안에 뽑은 인형을 push하는데 basket 리스트의 마지막 원소와 뽑은 인형이 같으면 마지막 원소를 비워주고 결과값인 answer에 1을 더하는 식으로 풀었다.

- 소스코드

  ```python
  def solution(board, moves):
      answer = 0
      basket = []
      for move in moves:
          try:
              i = 0
              # 뽑은 원소가 0이 아닐 때 까지 밑으로 내려가면서 원소를 뽑는다
              while True:             
                  item = board[i][move-1]
                  if item: 
                     	# 0이 아닌 원소를 발견하면, 해당 위치의 원소를 0으로 만들어 준다.
                      board[i][move-1] = 0
                      break
                  i += 1
              if basket:
                  if basket[-1] == item:
                      answer +=1
                      del[basket[-1]]
                  else:
                      basket.append(item)
              else:
                  basket.append(item)
          except IndexError:
              continue
      return 2 * answer
  ```

  


​      

### 2. 튜플

- 문제 설명

  - 셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.

    - (a1, a2, a3, ..., an)

    튜플은 다음과 같은 성질을 가지고 있습니다.

    1. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
    2. 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)
    3. 튜플의 원소 개수는 유한합니다.

    원소의 개수가 n개이고, **중복되는 원소가 없는** 튜플 `(a1, a2, a3, ..., an)`이 주어질 때(단, a1, a2, ..., an은 자연수), 이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다.

    - {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}

    예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는

    - {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}

    와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로

    - {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
    - {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
    - {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}

    는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.

    특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

    #### **[제한사항]**

    - s의 길이는 5 이상 1,000,000 이하입니다.
    - s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다.
    - 숫자가 0으로 시작하는 경우는 없습니다.
    - s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.
    - s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.
    - return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.

- 입출력 예시

  - | s                                 | result       |
    | --------------------------------- | ------------ |
    | `"{{2},{2,1},{2,1,3},{2,1,3,4}}"` | [2, 1, 3, 4] |
    | `"{{1,2,3},{2,1},{1,2,4,3},{2}}"` | [2, 1, 3, 4] |
    | `"{{20,111},{111}}"`              | [111, 20]    |
    | `"{{123}}"`                       | [123]        |
    | `"{{4,2,3},{3},{2,3,4,1},{2,3}}"` | [3, 2, 4, 1] |

- 내 풀이

 입력이 set 자료형으로 오는 게 아니라 문자열로 오는 형태이다. 일단은 입력받은 문자열을 리스트로 바꾸기 위해 split method를 사용해 리스트로 파싱해 주었다.

파싱한 후, 원소의 갯수가 적은 순서로 정렬을 했다. 정렬을 하면 [[a1], [a2, a1], [a3, a1, a2], ...] 이런 식으로 리스트 원소가 정렬 되게 되는데, 여기서 튜플의 원소를 구하려면, list[n]의 원소에서 list[n-1]의 원소를 빼 준다면, 튜플의 원소를 하나씩 구할 수 있게 되었다.

위의 방법으로 리스트의 원소만큼 반복해서 실행한다면, 결과값이 나오게 된다.

- 소스코드



```python
def solution(s):
    result = []
    item_list = []
    
    # 리스트의 원소를 ["1,2,3", "1,2,3,6", "1", "1,2"] 이런 식으로 만들어 준다
    s = s[1:-1]
    s_list = s.split('},{')
    s_list[0] = s_list[0][1:]
    s_list[-1] = s_list[-1][:-1]
    
    
    # 리스트의 원소를 [[1],[1,2],[1,2,3]..] 같은 형태로 만들어 준다.
    for item in s_list:
        item_list.append(item.split(','))
    item_list.sort(key=len)
    
    # 리스트의 원소들을 순회하면서 result 리스트를 만들어 준다. 리스트의 원소 리스트는 정렬이 되어있지 않기 때문에 set 을 사용해 줬다.
    while item_list:
        item = item_list.pop(0)
        if result:
            tmp = set(item) - set(result)
            result.append(list(tmp)[0])
        else:
            result.append(item[0])
            
    # ["a", "b", ..] => [a,b,...]
    return list(map(lambda x:int(x) ,result))
```

