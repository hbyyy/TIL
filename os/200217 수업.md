**과제!!**

다음 단 골 CS 지식 문항에 대해 구 체적으로 이해하 고 , 답변 준비하 기
1. 프로세스 간 에는 어떻 게 통신하는지 , 쓰레드와 비 교 해서 가 능한 상세하 게 설명해주세요 .
2. 프로세스와 쓰레드의 차이점에 대해 설명해주세요 .
3. 언제 멀티 프로세스를 사용하 고 , 언제 멀티 쓰레드를 써야하는지 가 능한 구 체적으로 설명해주세요 .
4. 쓰레드 동 기 화란 무엇이며 왜 사용해야하는지 예를 들어 설명해주세요 .
5. 뮤텍스와 세마포어의 차이점에 대해 간 략히 설명해주세요
과 제 : 다음 수업 까 지 , 위 문항에 대해 답변을 작성하여 , 제출하 기 ( dream @ fun - coding . org )





### Thread(쓰레드)

- 프로세스 안의 **경량 프로세스**라고도 한다.
- 프로세스와 다른점은, 쓰레드는 한 프로세스 안에 여러개가 만들어질 수 있고, 서로간에 자원을 공유한다. 또한 쓰레드는 동시에 여러 개가 실행이 가능하다.



쓰레드는 동기화 이슈가 있다. 동기화를 제대로 하지 않는다면 실행할 때 마다 다른 결과가 나오는 경우도 발생할 수 있다.

- 동기화 코드를 적절히 추가해서 해결할 수 있다.



### 동기화(Syncronization) 이슈

#### 동기화 이슈 해결 방안

##### Mutual exclusion(상호 배제)

쓰레드는 프로세스의 모든 데이터를 접근할 수 있으므로, 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요

어느 한 스레드가 공유 변수를 변경하는 동안 다른 스레드가 접근하지 못하게 lock을 건다.

예시>

```python
lock.acquire()
for i in range(10000):
	g_count += 1
lock.release()

lock = threading.Lock()
```

 보통의 동기화 이슈는 **쓰기** 가 발생할 때 일어난다. 만약, 쓰레드로 실행하는 부분에 쓰기를 하는 부분이 없다면 이러한 동기화 이슈를 고려할 필요가 없을 것이다. 반대로, 코드의 대부분이 동기화 이슈가 발생하는 부분이라 대부분의 실행 코드를  상호 배제를 이용하여 한 스레드만 실행하도록 한다면, 쓰레드를 쓰는 이유가 없어질 것이다.

 위의 상황처럼, 쓰레드를 실제로 사용하려면 많은 부분을 고려해야 할 것이다. 쓰레드 동기화 이슈로 발생하는 버그는 추적도 어려울 뿐더러, 똑같은 상황이 다시 발생하는 것도 기대하기 어렵다.



##### Mutex와 Semaphore

- Mutex
  - 임계구역에 하나의 스레드만 접근 가능
- Semaphore
  - 임계구역에 여러 스레드가 접근 가능
  - counter를 두어서 동시에 리소스에 접근할 수 있는 스레드 수를 제어할 수 있다.

>  세마포어는 현업 개발시 딱히 많이 쓰지 않고, 보통 Mutex를 이용해서 동기화 이슈를 처리한다고 한다.



**semaphore**

세마포어를 사용한다면, 임계 구역에 여러 스레드가 접근 가능할 수 있도록 할 수 있다.

- 여전히 동기화 이슈가 발생할 것이다. 이를 잘 처리해야하는데, 이것은 쉽지 않을 것이다.

예시>

```python
lock.acquire()
for i in range(10000):
	g_count += 1
lock.release()

lock = threading.Semaphore(2)
```





### 교착 상태(Deadlock)와 기아 상태(Starvation)

#### Deadlock 이란?

무한 대기 상태 

두 개 이상의 작업이 서로 상대방의 작업이 끝나기를 기다리고 있어서 다음 단계로 진행하지 못 하는 상태를 말한다.

> 꼭 쓰레드만이 아니라 프로세스에서도 이런 상태가 발생할 수 있다.



**교착 상태 발생 조건**

- 다음 네 가 지 조 건 이 모두 성립될 때 , 교 착상태 발생 가능성이 있음

1.  상호배제 ( Mutual exclusion ): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다 .
2.  점유대기 ( Hold and wait ): 프로세스가 할당된 자원을 가 진 상태에서 다른 자원을 기다린다 .
3.  비선점 ( No preemption ): 프로세스 가 어떤 자원의 사용을 끝낼 때 까지 그 자원을 뺏을 수 없다 .
4.  순환대기 ( Circular wait ): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다 .

> 위 조건 중 하나라도 성립하지 않는다면 교착 상태를 막을 수 있다
>
> 하지만, 하나를 해결한다는 것은 lock을 쓰지 않는다는 말이라 현실성이 없다. 참고로만 알아두자



#### Starvation 이란?

특정 프로세스의 우선 순위가 낮아 자원을 계속 할당받지 못하는 상태

- 여러 프로세스가 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당을 받지 못하는 상태를 말한다.



**해결 방안**

- 우선 순위를 수시로 변경해 줘서 각 프로세스가 높은 우선순위를 가질 기회를 주거나, 오래 기다힌 프로세스의 우선순위를 높여주면 해결할 수 있다
- FIFO 기반 요청 큐를 사용하는 방법도 있다.



###  파이썬과 쓰레드

- 파이썬은 한 개의 쓰레드만 사용이 가능하다.



그래도 유용한가?

유용하다. 쓰레드가 여러개 있고 어느 한 쓰레드가 sleep상태에 돌입한다면, 다른 쓰레드가 실행되고 작업을 계속 할 것이다. 이처럼 1개의 쓰레드만 사용이 가능해도, 없는 것 보다 좋은 성능을 보여준다

> 이 부분은 자세히 이해하지 못했다. [참고주소]([http://pythonstudy.xyz/python/article/24-%EC%93%B0%EB%A0%88%EB%93%9C-Thread](http://pythonstudy.xyz/python/article/24-쓰레드-Thread))



### IPC

 IPC의 기본 개념은, 커널 공간은 공유되기 때문에 이 공간을 이용하는 것

kernal space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식



IPC 종류가 많은 이유???